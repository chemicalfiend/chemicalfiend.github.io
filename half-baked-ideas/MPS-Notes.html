<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Pranay Venkatesh, University of Colorado Boulder, Created April 2025">

<title>Matrix Product States</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="MPS-Notes_files/libs/clipboard/clipboard.min.js"></script>
<script src="MPS-Notes_files/libs/quarto-html/quarto.js"></script>
<script src="MPS-Notes_files/libs/quarto-html/popper.min.js"></script>
<script src="MPS-Notes_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="MPS-Notes_files/libs/quarto-html/anchor.min.js"></script>
<link href="MPS-Notes_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="MPS-Notes_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="MPS-Notes_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="MPS-Notes_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="MPS-Notes_files/libs/bootstrap/bootstrap-1071d46f040c06eff9315d6ea0fc8c2c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="MPS-Notes.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Matrix Product States</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Pranay Venkatesh, University of Colorado Boulder, Created April 2025 </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<div id="c1ea3d6e" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.linalg <span class="im">import</span> svd, diagsvd</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="authors-note" class="level1">
<h1>Authors Note</h1>
<ul>
<li>These are highly oversimplified when possible to allow these concepts to make sense for someone that needs ELI5 explanations to understand anything (me). Please feel free to skip sections that belabour points.</li>
</ul>
</section>
<section id="introduction-to-mps" class="level1">
<h1>Introduction to MPS</h1>
<ul>
<li>If we have a quantum system existing on L sites, with each site having d local states per site where the states of a site are denoted by <span class="math inline">\(\{\sigma_i\}\)</span> for <span class="math inline">\(i = 1,... L\)</span>.</li>
<li>For spin-1/2 , d = 2, <span class="math inline">\(\sigma = |\uparrow\rangle\)</span> and <span class="math inline">\(|\downarrow\rangle\)</span>.</li>
<li>For site i, the Hilbert space <span class="math inline">\(\mathbb{H}_i = \{|1_i\rangle, \{|2_i\rangle, ... \{|d_i\rangle \}\)</span></li>
<li>And hence for the whole L-site quantum system the Hilbert space is <span class="math inline">\(\bigotimes\limits_{i=1}^{L} \mathbb{H}_i\)</span></li>
<li>The system state is then given by <span class="math inline">\(|\psi\rangle = \sum\limits_{\sigma_1 ... \sigma_L} c^{\sigma_1 ... \sigma_L} |\sigma_1 ... \sigma_L\rangle\)</span></li>
<li>The number of coefficients now scales as <span class="math inline">\(d^L\)</span> which kinda sucks if we have big systems.</li>
<li>The lowest order approximation to this is a mean-field approximation: <span class="math inline">\(c^{\sigma_1 ... \sigma_L} = c^{\sigma_1} c^{\sigma_2} ... c^{\sigma_L}\)</span>. This has favourable scaling of <span class="math inline">\(d L\)</span> but it misses entanglement entirely. e.g., there is no way to factor the singlet state <span class="math inline">\(|\psi\rangle = \frac{1}{\sqrt{2}}(|\uparrow \downarrow\rangle - |\downarrow \uparrow\rangle\)</span> into a product such that <span class="math inline">\(c^{\uparrow \downarrow} = c^{\uparrow} c^{\downarrow}\)</span>.</li>
<li>To capture entanglement, instead of maintaining a product of scalar coefficients, we generalise to a product of matrices, <span class="math inline">\(c^{\sigma_1 ... \sigma_L} = A^{\sigma_1} . A^{\sigma_2} ... A^{\sigma_L}\)</span></li>
<li>The system state can now be written as <span class="math inline">\(|\psi\rangle = \sum \limits_{\sigma_1 ... \sigma_L} A^{\sigma_1} ... A^{\sigma_L} |\sigma_1 ... \sigma_L\rangle\)</span>.</li>
<li>Note that this decomposition is not unique : it has a gauge degree of freedom where you can plug in an <span class="math inline">\(X X^{-1}\)</span> between any two matrices and absorb them into the A’s to get a different set of matrices : <span class="math inline">\(A^{\sigma_1} ... A^{\sigma_j} A^{\sigma_k}...A^{\sigma_L} \to A^{\sigma_1} ... A^{\sigma_j} X X^{-1} A^{\sigma_k}...A^{\sigma_L} \to A^{\sigma_1} ... M^{\sigma_j} M^{\sigma_k}...A^{\sigma_L}\)</span>. Where <span class="math inline">\(M^{\sigma_j} = A^{\sigma_j} X\)</span> and <span class="math inline">\(M^{\sigma_k} = X^{-1} A^{\sigma_k}\)</span>.</li>
</ul>
</section>
<section id="mps-preparation-wavefunction" class="level1">
<h1>MPS Preparation (wavefunction)</h1>
<ul>
<li>Let us now go over how we can decompose <span class="math inline">\(c^{\sigma_1 ... \sigma_L}\)</span> to a matrix product state <span class="math inline">\(= A^{\sigma_1} A^{\sigma_2} ... A^{\sigma_L}\)</span>. We’ll do this step-wise and see how a pattern emerges.</li>
<li><strong>Reshape 1</strong> : If we think of the coefficients c as one giant vector indexed by a massive index of all the <span class="math inline">\(\sigma\)</span>’s, then we can reshape the vector c into a matrix <span class="math inline">\(\Psi_{\sigma_1, \sigma_2...\sigma_L}\)</span>, basically yanking out one index <span class="math inline">\(\sigma_1\)</span>. If <span class="math inline">\(\sigma_1\)</span> has d values then we get a stack of d vectors of size L-1, where the vectors are indexed by <span class="math inline">\(\sigma_2\)</span> to <span class="math inline">\(\sigma_L\)</span>.</li>
<li><strong>SVD 1</strong> : We can now perform an SVD operation on <span class="math inline">\(\Psi\)</span> to get <span class="math inline">\(U S V^{\dagger}\)</span> where an entry <span class="math inline">\(\Psi_{\sigma_1, \sigma_2...\sigma_L} = \sum \limits_{a_1} U_{\sigma_1, a_1} S_{a_1, a_1} (V^{\dagger})_{a_1, \sigma_2...\sigma_L}\)</span>. Why do we use SVD instead of the other billion matrix factorisation techniques? Go to Appendix A for more.</li>
<li><strong>Slicing 1</strong> : We can take U and slice it into d row vectors : <span class="math inline">\(\{A^{\sigma_1}\}\)</span> with <span class="math inline">\(A_{1, a_1}^{\sigma_1} = U_{\sigma_1, a_1}\)</span> here the index “1” for A is a dummy index since each <span class="math inline">\(A\)</span> is a row vector, so it is just the element <span class="math inline">\(a_1\)</span> of <span class="math inline">\(A\)</span>. This will not be the case for subsequent operations.</li>
<li>Now the state looks like this : <span class="math inline">\(c^{\sigma_1 ... \sigma_L} = \sum\limits_{a_1} A^{\sigma_1}_{1, a_1} c^{a_1, \sigma_2 ... \sigma_L}\)</span> where <span class="math inline">\(c^{a_1, \sigma_2 ... \sigma_L} = S_{a_1, a_1} V_{a_1, \sigma_2 ... \sigma_L}^{\dagger}\)</span></li>
<li>We can write a simple python code for these operations:</li>
</ul>
<div id="444ce353" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate random coefficients to demonstrate use case.</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.random.rand(d<span class="op">**</span>L)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>Ψ <span class="op">=</span> np.reshape(c, (d, d<span class="op">**</span>(L<span class="op">-</span><span class="dv">1</span>)))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>U, s, Vt <span class="op">=</span> svd(Ψ, full_matrices<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create diagonal matrix of singular values</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> diagsvd(s, U.shape[<span class="dv">1</span>], Vt.shape[<span class="dv">0</span>])</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>As <span class="op">=</span> []</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(d):</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> U[i, :]</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    As.append(A)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e6c49077" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>cnew <span class="op">=</span> np.dot(S, Vt)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Reconstructing coefficient vector from As and cnew to verify</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>ctest <span class="op">=</span> np.zeros((d, d<span class="op">**</span>L<span class="op">//</span><span class="dv">2</span>))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(d):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    ctest <span class="op">+=</span> np.outer(As[i], cnew[i, :])</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.allclose(ctest.flatten(), c))</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># allclose to check approximate equals, translated from julia \approx for unit tests.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>True</code></pre>
</div>
</div>
<ul>
<li>Let us continue this for one more step. So we now have <span class="math inline">\(c^{a_1, \sigma_2, ...\sigma_L}\)</span>.</li>
<li><strong>Reshape 2</strong> : Yank <span class="math inline">\(\sigma_2\)</span> out as a dimension to get another matrix <span class="math inline">\(\Psi_{a_1 \sigma_2, \sigma_3 ... \sigma_L}\)</span></li>
<li><strong>SVD 2</strong> : <span class="math inline">\(\Psi = U S V^{\dagger}\)</span>, which means the element <span class="math inline">\(\Psi_{a_1\sigma_2, \sigma_3 ... \sigma_L} = \sum \limits_{a_2} U_{a_1 \sigma_2, a_2} S_{a_2, a_2} V^{\dagger}_{a_2, \sigma_3...\sigma_L}\)</span></li>
<li><strong>Slice 2</strong> : Now we slice into matrices and not row vectors since <span class="math inline">\(a_1, a_2\)</span> are two indices to think about, so we get <span class="math inline">\(A_{a_1, a_2}^{\sigma_2} = U_{a_1 \sigma_2, a_2}\)</span>.</li>
<li>Which now means the current state of our coefficient vector is <span class="math inline">\(c^{\sigma_1, \sigma_2, ...} = \sum \limits_{a_1, a_2} A_{1, a_1}^{\sigma_1} A_{a_1, a_2}^{\sigma_2} c^{a_2 \sigma_3 ... \sigma_L}\)</span> where <span class="math inline">\(c^{a_2 \sigma_3 ... \sigma_L} =  S_{a_2, a_2} V_{a_2, \sigma_3 ...\sigma_L}^{\dagger}\)</span></li>
<li>And we can keep doing this to the remaining parts of the coefficient until the last one.</li>
<li>Let us look at a python code for step 2 as well:</li>
</ul>
<div id="9635cb9d" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Ψ<span class="dv">2</span> <span class="op">=</span> np.reshape(cnew, (d<span class="op">**</span><span class="dv">2</span>, d<span class="op">**</span>(L<span class="op">-</span><span class="dv">2</span>)))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>U2, s2, Vt2 <span class="op">=</span> svd(Ψ<span class="dv">2</span>, full_matrices<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>S2 <span class="op">=</span> diagsvd(s2, U2.shape[<span class="dv">1</span>], Vt2.shape[<span class="dv">0</span>])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>As2 <span class="op">=</span> []</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(d):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    A <span class="op">=</span> U2[(i<span class="op">*</span>d):((i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>d), :]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    As2.append(A)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>cnew2 <span class="op">=</span> np.dot(S2, Vt2)  <span class="co"># In case you want to keep going</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Reconstruct and verify</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>Ψ_reconstr <span class="op">=</span> [np.dot(A, cnew2) <span class="cf">for</span> A <span class="kw">in</span> As2]</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>ctest2 <span class="op">=</span> np.concatenate(Ψ_reconstr).flatten()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8ddc9f55" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(np.allclose(ctest2, cnew.flatten()))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>True</code></pre>
</div>
</div>
<ul>
<li>This keeps going until we finally get <span class="math inline">\(c^{\sigma_1 ... \sigma_L} = \sum \limits_{a_1} \sum \limits_{a_2} ... \sum \limits_{a_{L-1}} A_{1, a_1}^{\sigma_1} A_{a_1, a_2}^{\sigma_2}...A_{a_{L-2}, a_{L-1}}^{\sigma_{L-1}} A_{a_L, 1}^{\sigma_L} = A^{\sigma_1} ... A^{\sigma_L}\)</span></li>
<li>Note that at the last step again similar to step 1 we have a dummy index “1” but as the second index.</li>
<li>Another note : Dimensionality increases towards the centre of the product and decreases towards either end. <span class="math inline">\(a_1\)</span> has d dimensions, <span class="math inline">\(a_2\)</span> is <span class="math inline">\(d^2\)</span> dimensions and so on.</li>
<li>Another another note : While here we take the <span class="math inline">\(A\)</span>’s to be the <span class="math inline">\(U\)</span>’s of the SVD, we can always take <span class="math inline">\(A\)</span> to be <span class="math inline">\(U(S^{\frac{1}{2}})\)</span> and let the “residue” be <span class="math inline">\((S^{\frac{1}{2}}) V^{\dagger}\)</span>. This is more common and I will use this later on.</li>
<li>Fermions, due to exchange interactions save you since d is often maxed out. For these spin-lattice models d = 2 and for the Hubbard model d = 4 (<span class="math inline">\(|0\rangle, |\uparrow\rangle, |\downarrow\rangle, |\uparrow\downarrow\rangle\)</span>). However for systems like bosons, d can even be infinite, so you have to start thinking of truncation up to some set <span class="math inline">\(d_{max}\)</span> which is a method parameter that you have to converge.</li>
</ul>
</section>
<section id="mps-block-diagram-notation" class="level1">
<h1>MPS Block Diagram Notation</h1>
<p>There’s a block diagram notation for representing MPS’s conveniently. It’s not always clear what the diagrams mean so here is a guide on what the different chunks of these diagrams indicate and how you can use them to make life easy.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/mps1.png" class="img-fluid figure-img"></p>
<figcaption>matrix</figcaption>
</figure>
</div>
<ul>
<li>A circle is one chunk of your matrix product state. The image above is a matrix (or a rank-2 tensor). How do I know that it’s a matrix? Because it has two legs. Each leg represents an index.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/mps-singletensor.png" class="img-fluid figure-img"></p>
<figcaption>tensor</figcaption>
</figure>
</div>
<ul>
<li><p>This object is a rank-3 tensor, it would take specifying 3 indices to fully get the location of an element of this tensor, e.g.&nbsp;<span class="math inline">\(K_{111} = 10\)</span>. In python terms <span class="math inline">\(K[0][0][0] = 10.0\)</span>.</p></li>
<li><p>On occassion, you might see a number on one of these legs, which is the dimension of that matrix along that particular leg.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/mps1dims.png" class="img-fluid figure-img"></p>
<figcaption>matrix dims</figcaption>
</figure>
</div>
<p>This, for example, is a 3x3 matrix.</p>
<ul>
<li><p>How do we represent a matrix product state then? Let’s take two matrices and take their product. Mathematically how would you represent the product of two matrices C = AB? You have at max 3 unique indices in the beginning <span class="math inline">\(A_{ij}\)</span> and <span class="math inline">\(B_{jk}\)</span> (let’s say i goes from 1 to m, j goes from 1 to n and k goes from 1 to p) since A can have as many rows as B can have columns and <span class="math inline">\(C_{ik} = \sum_j A_{ij} B_{jk}\)</span>, so you only need 3 legs in total for a matrix product.</p></li>
<li><p>What we do to represent the fact that we store a matrix product is to connect the leg of the matrices whose index we sum over (in this example it was <span class="math inline">\(j\)</span> since that was the common index). We represent the matrix product in this form :</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/mps2.png" class="img-fluid figure-img"></p>
<figcaption>matrix product</figcaption>
</figure>
</div>
<p>A leg shared between two matrices (or tensors) is called a <strong>“bond”</strong>. The maximum index value of the bond variable (here <span class="math inline">\(j = n\)</span> would be the maximum value that <span class="math inline">\(j\)</span> can take) is called the <strong>“bond dimension”</strong>.</p>
<p>The object that we generated from wavefunction MPS construction earlier looks like this :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/mps3.png" class="img-fluid figure-img"></p>
<figcaption>mps wavefunction</figcaption>
</figure>
</div>
<p>The first and last legs have unit dimension since they’re dummies.</p>
<p>The object we started out with (the giant c tensor) looks like this:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/c_vec.png" class="img-fluid figure-img"></p>
<figcaption>c tensor</figcaption>
</figure>
</div>
<p>Matrix product operators (discussed later) operate on matrix product states. Mathematically, they are the same <em>type</em> of objects as matrix product states (in python we literally use the same class for both of them), but in standard notation, the MPOs are represented by squares. So it’s worth getting comfortable seeing this sort of thing :</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/mps-mpo.png" class="img-fluid figure-img"></p>
<figcaption>MPO multiplying an MPS</figcaption>
</figure>
</div>
<p>Here the MPS on top gets operated on by the MPO in the middle to produce another MPS in the bottom. The top two legs of the MPO and the bottom two legs of the red MPS are going to touch and hence the touching legs need to have the same dimensions (and then you sum over the index corresponding to that leg).</p>
</section>
<section id="mps-preparation-density-matrix" class="level1">
<h1>MPS Preparation (Density Matrix)</h1>
<ul>
<li>Okay, so we showcased the basic MPS construction for a wavefunction, but we don’t really care about that, so let’s do this for a density matrix.</li>
<li>Let’s take a representative system for spin dynamics : say you have 1 system spin interacting with 2 bath spins, so that’s totally just a 3-spin system.</li>
<li>Initially let’s assume this 3-spin system comes in the following avatar : the system spin is in the excited state and the bath spins are thermalised at some inv-temp <span class="math inline">\(\beta\)</span> and none of them are entangled to each other. So the state is just <span class="math inline">\(\rho_s \otimes \rho_{b1} \otimes \rho_{b2}\)</span>.</li>
<li>Refer to Appendix B for <span class="math inline">\(\otimes\)</span> and <span class="math inline">\(\oplus\)</span> in case you’re rusty.</li>
<li>There’s multiple ways you can turn this direct product of density matrices into an MPS. Here are some forms and you can convince yourself that they all represent the same thing (within a reshape of each other):</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/DM-mps.png" class="img-fluid figure-img"></p>
<figcaption>Density matrix MPS avatars</figcaption>
</figure>
</div>
<ul>
<li>Here I’ve showcased the MPS of density matrices in 3 avatars.</li>
<li>The top (red) one is the form that is used in DMRG.</li>
<li>The second form (green) has the 2x2 density matrix reshaped into a single 4x1 object. This is called the Choi-transformed representation.</li>
<li>The third form (blue) is a “split” representation of the MPS. The magenta box represents the nodes and legs that correspond to the system spin and the olive boxes are the nodes and legs corresponding to each bath spin.</li>
<li>Does it matter how we order the system and bath spins? This seems to be an open research question. But we will conveniently plonk the system spin in the beginning and place all the bath spins afterwards. Within the MPS formalism, entanglement seems to be encoded pairwise and captures the entire entanglement of the system.</li>
</ul>
<p>Okay, good. So how do we actually make one of these?</p>
<p>Let us define some convenient params (in file params.py) that describe the relevant parameters and so on that we use for MPS construction. These are not extremely important conceptually, hopefully comments illustrate what each term is doing in case confusion arises later :</p>
<div id="2475df39" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>small <span class="op">=</span> <span class="fl">1e-14</span> <span class="co"># Cutoff for SVD truncation</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">#mmax = 6</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>nb1 <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>nb2 <span class="op">=</span> nb1 <span class="co"># redundant, can replace all instances with nb1.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>nrtt <span class="op">=</span> <span class="dv">30</span> <span class="co"># Caps the bond dimension for the MPS in TDVP propagation.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>nrmax <span class="op">=</span> <span class="dv">1000</span> <span class="co"># Not sure what this is</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>nsteps <span class="op">=</span> <span class="dv">10000</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>nbath <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>nlevel <span class="op">=</span> nbath<span class="op">*</span><span class="dv">2</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>ndvr <span class="op">=</span> <span class="dv">2</span> <span class="co"># System dimensions.</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>domega <span class="op">=</span> <span class="fl">2.5</span> <span class="co"># No idea what this is.</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>eta <span class="op">=</span> <span class="fl">0.5</span> <span class="co"># No idea what this is .</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> <span class="fl">1.0</span> <span class="co"># No idea what this is.</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>omega_s <span class="op">=</span> <span class="fl">0.0</span> <span class="co"># System splitting energy.</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>delta   <span class="op">=</span> <span class="fl">1.0</span> <span class="co"># No idea what this is.</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>omega_b <span class="op">=</span> np.zeros(nbath,dtype <span class="op">=</span> np.float64) <span class="co"># Bath spin splitting energy.</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>eta_sb  <span class="op">=</span> np.zeros(nbath,dtype <span class="op">=</span> np.float64) <span class="co"># Sys-bath coupling.</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nbath):</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>  omega_b[i] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>  eta_sb[i]  <span class="op">=</span> <span class="fl">0.5</span><span class="op">/</span>np.sqrt(nbath) <span class="co"># Arbitrary definition of system-bath coupling.</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a><span class="co"># read/write pall</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="co"># write True prompts MPS construction</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a><span class="co"># read True prompts MPS propagation</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>read_pall <span class="op">=</span> <span class="va">False</span>   </span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>write_pall <span class="op">=</span> <span class="va">False</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>pall_file <span class="op">=</span> <span class="st">"pallDimer0"</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="co"># paramaters</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>nb <span class="op">=</span> np.zeros(nlevel<span class="op">+</span><span class="dv">2</span>,dtype<span class="op">=</span>np.int64)</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>nb[<span class="dv">0</span>] <span class="op">=</span> ndvr</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>nb[<span class="dv">1</span>] <span class="op">=</span> nb1</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>nb[<span class="dv">2</span>:nlevel<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> nb2</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>nb[nlevel<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> ndvr</span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>nbmat <span class="op">=</span> nb<span class="op">**</span><span class="dv">2</span> <span class="co"># MPO bond dimension, square of bond dimensions of the MPS.</span></span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a><span class="co"># System Hamiltonian</span></span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>hsys <span class="op">=</span> np.array(([omega_s<span class="op">/</span><span class="fl">2.0</span>,delta],[delta,<span class="op">-</span>omega_s<span class="op">/</span><span class="fl">2.0</span>]),dtype<span class="op">=</span>np.float64)</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a><span class="co"># Bath spin Hamiltonian</span></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>hbath <span class="op">=</span> []</span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nbath):</span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a>  hbath.append(np.array(([omega_b[i]<span class="op">/</span><span class="fl">2.0</span>,<span class="fl">0.0</span>],[<span class="fl">0.0</span>,<span class="op">-</span>omega_b[i]<span class="op">/</span><span class="fl">2.0</span>]),dtype<span class="op">=</span>np.float64))</span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a><span class="co"># Pauli matrixs</span></span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>sigma_x <span class="op">=</span> np.array(([<span class="fl">0.0</span>,<span class="fl">1.0</span>],[<span class="fl">1.0</span>,<span class="fl">0.0</span>]),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>sigma_y <span class="op">=</span> np.array(([<span class="fl">0.0</span>,<span class="op">-</span><span class="ot">1.0j</span>],[<span class="ot">1.0j</span>,<span class="fl">0.0</span>]),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>sigma_z <span class="op">=</span> np.array(([<span class="fl">1.0</span>,<span class="fl">0.0</span>],[<span class="fl">0.0</span>,<span class="op">-</span><span class="fl">1.0</span>]),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>sdvr <span class="op">=</span> np.array(([<span class="op">-</span><span class="fl">1.0</span>,<span class="fl">1.0</span>]),dtype<span class="op">=</span>np.float64) <span class="co"># No idea what this is.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Okay, now let’s start making the MPS. We also need an object to store the MPS (also written within the file params.py). We are going to make an MPS in the <strong>split</strong> avatar (the blue MPS in the diagram above). Python code for the object:</p>
<div id="8e6c263a" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Density:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 2 nodes for each bath spin and 2 nodes for system spin in split notation.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nb <span class="op">=</span> np.empty((nlevel<span class="op">+</span><span class="dv">2</span>),dtype<span class="op">=</span>np.int64)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nodes <span class="op">=</span> []</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Clone our MPS</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> copy(<span class="va">self</span>):</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        rout <span class="op">=</span> Density()</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        rout.nb <span class="op">=</span> <span class="va">self</span>.nb</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        nlen <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.nodes)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nlen):</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            vtmp <span class="op">=</span> <span class="va">self</span>.nodes[i].copy()</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            rout.nodes.append(vtmp)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rout</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get the dims of all the tensors in the MPS.</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> ndim(<span class="va">self</span>):</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        nlen <span class="op">=</span> <span class="bu">len</span>(<span class="va">self</span>.nodes)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        ndim <span class="op">=</span> np.empty((<span class="dv">3</span>,nlen),dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nlen):</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>            ndim[<span class="dv">0</span>,i] <span class="op">=</span> <span class="va">self</span>.nodes[i].shape[<span class="dv">0</span>]</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            ndim[<span class="dv">1</span>,i] <span class="op">=</span> <span class="va">self</span>.nodes[i].shape[<span class="dv">1</span>]</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            ndim[<span class="dv">2</span>,i] <span class="op">=</span> <span class="va">self</span>.nodes[i].shape[<span class="dv">2</span>]</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ndim</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now want to store the split form of the unentangled direct product state as the initialised state of our MPS.</p>
<ul>
<li><p>Start by defining the density matrix for the system <span class="math inline">\(\rho_s = \begin{pmatrix}1 &amp; 0 \\ 0 &amp; 0 \end{pmatrix}\)</span></p></li>
<li><p>Split the system spin into two matrices by performing an SVD: <span class="math inline">\(\rho_s \to U S V^{\dagger}\)</span> and then storing the matrix <span class="math inline">\(U(S^{\frac{1}{2}})\)</span> and the matrix <span class="math inline">\((S^{\frac{1}{2}}) V^{\dagger}\)</span> as two nodes in the MPS.</p></li>
<li><p>Define bath spins that are defined by <span class="math inline">\(\rho_b = \text{e}^{-\beta H_b}\)</span>. Then repeat the same for the bath spins to split them and get 2 nodes for each bath spin.</p></li>
</ul>
<p>Define a file init_rho.py which has the following function:</p>
<div id="83a37206" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> init_rho():</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># System spin splitting :</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    rho0 <span class="op">=</span> np.zeros((ndvr,ndvr),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    rho0[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    rhoall <span class="op">=</span> Density()</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    u1,s1,vt1 <span class="op">=</span> np.linalg.svd(rho0,full_matrices<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    ii <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, ndvr<span class="op">+</span><span class="dv">1</span>,<span class="dv">1</span>):</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s1[i<span class="op">-</span><span class="dv">1</span>]<span class="op">&gt;</span> small:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            ii <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"rank of initial rho ="</span>, ii)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> ii<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            sys.exit(<span class="st">"initial density operator has rank 0, stop"</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> (ii <span class="op">&gt;</span>  nrtt):</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            sys.exit(<span class="st">"rank of initial density larger than nrtt, stop"</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    vl <span class="op">=</span> np.zeros((<span class="dv">1</span>,  ndvr,  nrtt),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    vr <span class="op">=</span> np.zeros(( nrtt,  ndvr,  nrtt),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>( ndvr):</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ii):</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>            vl[<span class="dv">0</span>,i,j] <span class="op">=</span> u1[i,j]<span class="op">*</span>np.sqrt(s1[j])</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            vr[j,i,<span class="dv">0</span>] <span class="op">=</span> vt1[j,i]<span class="op">*</span>np.sqrt(s1[j])</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    rhoall.nodes.append((vl))</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    rhoall.nodes.append((vr))</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># bath spins splitting:</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>( nbath<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>        rhob0 <span class="op">=</span> np.zeros(( ndvr, ndvr), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>        rhob0[<span class="dv">1</span>,<span class="dv">1</span>] <span class="op">=</span> <span class="fl">1.0</span><span class="op">/</span>(<span class="fl">1.0</span> <span class="op">+</span> np.exp(<span class="op">-</span> beta<span class="op">*</span> omega_b[i]))</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>        rhob0[<span class="dv">0</span>,<span class="dv">0</span>] <span class="op">=</span> np.exp(<span class="op">-</span> beta<span class="op">*</span> omega_b[i])<span class="op">/</span>(<span class="fl">1.0</span> <span class="op">+</span> np.exp(<span class="op">-</span> beta<span class="op">*</span> omega_b[i]))</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>        u2,s2,vt2 <span class="op">=</span> np.linalg.svd(rhob0,full_matrices<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>        iii <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, ndvr<span class="op">+</span><span class="dv">1</span>,<span class="dv">1</span>):</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s2[i<span class="op">-</span><span class="dv">1</span>]<span class="op">&gt;</span> small:</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>                iii <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> iii<span class="op">==</span><span class="dv">0</span>:</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>            sys.exit(<span class="st">"initial density operator has rank 0, stop"</span>)</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> (iii <span class="op">&gt;</span>  nrtt):</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>            sys.exit(<span class="st">"rank of initial density larger than nrtt, stop"</span>)</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>        vtmp1 <span class="op">=</span> np.zeros(( nrtt,  ndvr,  nrtt),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>        vtmp2 <span class="op">=</span> np.zeros(( nrtt,  ndvr,  nrtt),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>( ndvr):</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(iii):</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>                vtmp1[<span class="dv">0</span>,j,k] <span class="op">=</span> u2[j,k]<span class="op">*</span>np.sqrt(s2[k])</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>                vtmp2[k,j,<span class="dv">0</span>] <span class="op">=</span> vt2[k,j]<span class="op">*</span>np.sqrt(s2[k])</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>    rhoall.nodes.append((vtmp1))</span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>    rhoall.nodes.append((vtmp2))</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>    vtmp1 <span class="op">=</span> np.zeros(( nrtt,  ndvr,  nrtt),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>    vtmp2 <span class="op">=</span> np.zeros(( nrtt,  ndvr, <span class="dv">1</span>),dtype<span class="op">=</span>np.complex128)</span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>( ndvr):</span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(iii):</span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a>            vtmp1[<span class="dv">0</span>,j,k] <span class="op">=</span> u2[j,k]<span class="op">*</span>np.sqrt(s2[k])</span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a>            vtmp2[k,j,<span class="dv">0</span>] <span class="op">=</span> vt2[k,j]<span class="op">*</span>np.sqrt(s2[k])</span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a>    rhoall.nodes.append((vtmp1))</span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>    rhoall.nodes.append((vtmp2))</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a>    rhoall.nb <span class="op">=</span>  nb</span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"length of rhoall: </span><span class="sc">{}</span><span class="st">"</span>.<span class="bu">format</span>(<span class="bu">len</span>(rhoall.nodes)))</span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"rhoall initialization done!"</span>)</span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rhoall</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s look at what this does :</p>
<div id="ba13d761" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>MPS <span class="op">=</span> init_rho()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>rank of initial rho = 1
rank of initial rho = 1
length of rhoall: 6
rhoall initialization done!</code></pre>
</div>
</div>
</section>
<section id="mpo-preparation" class="level1">
<h1>MPO Preparation</h1>
<ul>
<li>So you made an MPS. Great! No point just having it sit around so lets create some devices to poke and prod our MPS into doing something.</li>
<li>This is the MPO: a Matrix Product Operator that will act on the MPS.</li>
<li>Take the LvN equation for example : <span class="math inline">\(\frac{d\rho}{dt} = [H, \rho] = H \rho - \rho H\)</span>. How do we construct MPOs to do the <span class="math inline">\(H \rho\)</span> and <span class="math inline">\(\rho H\)</span> operations?</li>
<li>Let’s take a step back and make a Hamiltonian <span class="math inline">\(H\)</span> for the 3 spin system. Say we’re doing 3 spins in full decoherence : <span class="math inline">\(H = \frac{\omega_s}{2} \sigma_0^{z} + \Delta \sigma_0^{x} + \sum_{i=1}^{2} \frac{\omega_i}{2} \sigma_z^{i} + \sum_i \eta_i \sigma_i^{x} \sigma_0^{z}\)</span>.</li>
<li>First two terms are system Hamiltonian <span class="math inline">\(H_s\)</span>. Second term is bath Hamiltonian <span class="math inline">\(H_b\)</span> and third term is interaction <span class="math inline">\(H_I\)</span>.</li>
<li>Hence the RHS of the LvN equation is going to be <span class="math inline">\(H_s \rho - \rho H_s + H_b \rho - \rho H_b\)</span> and so on.</li>
<li>Let us just consider the system terms <span class="math inline">\(H_s \rho - \rho H_s\)</span> first.</li>
<li>The MPO for the first part looks like this :</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/mpo_rHs.png" class="img-fluid figure-img"></p>
<figcaption>MPO for <span class="math inline">\(H_s \rho\)</span></figcaption>
</figure>
</div>
<ul>
<li>The MPO for the second part looks like this :</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="mps-figs/mpo_Hsr.png" class="img-fluid figure-img"></p>
<figcaption>MPO for <span class="math inline">\(\rho H_s\)</span></figcaption>
</figure>
</div>
<p>Add these two to get the effective operator for the entire system part.</p>
<p>My notes in Appendix B tells you why this is the case.</p>
<p>This is how you make an MPO for a given Hamiltonian. Let us define some utility functions first.</p>
<p>Code for splitting (QR and SVD) in file split.py:</p>
<div id="4c9195e9" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.linalg <span class="im">as</span> lg</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">#=================================================================</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># this do the rq split for a 3D tensor, based on (a,b,c) =&gt; (a,b*c)</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># need to reshape q to 3D</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_rq(xx):</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    y1, m, y2 <span class="op">=</span> np.shape(xx)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    yy <span class="op">=</span> np.reshape(xx, (y1, y2<span class="op">*</span>m), order<span class="op">=</span><span class="st">'F'</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    r, q <span class="op">=</span> lg.rq(yy, mode<span class="op">=</span><span class="st">'economic'</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    q1 <span class="op">=</span> np.reshape(q, (<span class="bu">min</span>(y1, y2<span class="op">*</span>m), m, y2), order<span class="op">=</span><span class="st">'F'</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> r, q1</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co">#=================================================================</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co"># this do the rq split for a 3D tensor, based on (a,b,c) =&gt; (a*b,c)</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="co"># need to reshape q to 3D</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_qr(xx):</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>    y1, m, y2 <span class="op">=</span> np.shape(xx)</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>    yy <span class="op">=</span> np.reshape(xx, (y1<span class="op">*</span>m, y2), order<span class="op">=</span><span class="st">'F'</span>)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>    q, r <span class="op">=</span> lg.qr(yy, mode<span class="op">=</span><span class="st">'economic'</span>)</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>    q1 <span class="op">=</span> np.reshape(q, (y1, m, <span class="bu">min</span>(y1<span class="op">*</span>m, y2)), order<span class="op">=</span><span class="st">'F'</span>)</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> q1, r</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span class="co">#====================================================</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a><span class="co"># this is our version of the split_w_truncation function</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a><span class="co"># using svd</span></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> split_svd_rq(xx):</span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># do the svd</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>    y1, m, y2 <span class="op">=</span> np.shape(xx)</span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>    yy <span class="op">=</span> np.reshape(xx, (y1, y2<span class="op">*</span>m), order<span class="op">=</span><span class="st">'F'</span>)</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>    u1, s1, vt1 <span class="op">=</span> lg.svd(yy, full_matrices<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------</span></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># find jmax</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s1)):</span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (s1[i] <span class="op">&lt;</span> s1[<span class="dv">0</span>]<span class="op">*</span>small):</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a>    jmax <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (jmax <span class="op">&gt;</span> nrmax): jmax <span class="op">=</span> nrmax</span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a><span class="co">#-----------------------------------</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a><span class="co"># do the truncation</span></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a>    u2 <span class="op">=</span> u1[:, <span class="dv">0</span>:jmax]</span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a>    vt2 <span class="op">=</span> vt1[<span class="dv">0</span>:jmax, :]</span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(jmax):</span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a>        u2[:, i] <span class="op">*=</span> s1[i]</span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a>    q1 <span class="op">=</span> np.reshape(vt2, (jmax, m, y2), order<span class="op">=</span><span class="st">'F'</span>)</span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> u2, q1</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Code for tensor truncation (in trun.py) :</p>
<div id="b53a1c24" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">#==========================================</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co"># truncation based on the 2-sweep method</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Note, added normaliation similar to the orginal fortran code....</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># also use a custom svd truncation, the one with tn may cause problems somehow</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> trun_tensor(rin):</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    rout <span class="op">=</span> Density()</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    rout.nb <span class="op">=</span> rin.nb</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    nlen <span class="op">=</span> <span class="bu">len</span>(rin.nodes)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    nrm <span class="op">=</span> []</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------------------</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># QR for the first matrix</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    q, r <span class="op">=</span> split_qr(rin.nodes[<span class="dv">0</span>])</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    rout.nodes.append(q)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># normalize</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>    nrml <span class="op">=</span> np.sqrt(np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(r)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">#print("nrml =", nrml)</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (nrml <span class="op">&lt;</span> <span class="fl">1.e-3</span>): nrml <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    nrm.append(nrml)</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    r <span class="op">*=</span> <span class="fl">1.0</span><span class="op">/</span>nrml</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------------------</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a><span class="co"># middle ones</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nlen<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>):</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>        rtmp <span class="op">=</span> np.tensordot(r, rin.nodes[i], (<span class="dv">1</span>, <span class="dv">0</span>))</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a>        q, r <span class="op">=</span> split_qr(rtmp)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>        rout.nodes.append(q)</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a>        nrm.append(np.sqrt(np.<span class="bu">sum</span>(np.<span class="bu">abs</span>(r)<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (nrm[i] <span class="op">&lt;</span> <span class="fl">1.e-3</span>): nrm[i] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>        r <span class="op">*=</span> <span class="fl">1.0</span><span class="op">/</span>nrm[i]</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------------------</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a><span class="co"># the last one</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a>    rtmp <span class="op">=</span> np.tensordot(r, rin.nodes[nlen<span class="op">-</span><span class="dv">1</span>], ((<span class="dv">1</span>), (<span class="dv">0</span>)))</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>    rout.nodes.append(rtmp)</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------------------</span></span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the real truncation from the right</span></span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a>    rin <span class="op">=</span> trun_tensor_right(rout)</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-50"><a href="#cb14-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-51"><a href="#cb14-51" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------------------</span></span>
<span id="cb14-52"><a href="#cb14-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># get the renormalization factors back </span></span>
<span id="cb14-53"><a href="#cb14-53" aria-hidden="true" tabindex="-1"></a>    nrml <span class="op">=</span> np.<span class="bu">sum</span>(np.log(nrm))</span>
<span id="cb14-54"><a href="#cb14-54" aria-hidden="true" tabindex="-1"></a>    nrml <span class="op">=</span> np.exp(nrml<span class="op">/</span>nlen)</span>
<span id="cb14-55"><a href="#cb14-55" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-56"><a href="#cb14-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nlen):</span>
<span id="cb14-57"><a href="#cb14-57" aria-hidden="true" tabindex="-1"></a>        rin.nodes[i] <span class="op">*=</span> nrml</span>
<span id="cb14-58"><a href="#cb14-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-59"><a href="#cb14-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rin</span>
<span id="cb14-60"><a href="#cb14-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-61"><a href="#cb14-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-62"><a href="#cb14-62" aria-hidden="true" tabindex="-1"></a><span class="co">#==============================================</span></span>
<span id="cb14-63"><a href="#cb14-63" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> trun_tensor_right(rin):</span>
<span id="cb14-64"><a href="#cb14-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">#print("trun_right, shape of rin",rin.ndim())</span></span>
<span id="cb14-65"><a href="#cb14-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-66"><a href="#cb14-66" aria-hidden="true" tabindex="-1"></a>    rout <span class="op">=</span> rin.copy()</span>
<span id="cb14-67"><a href="#cb14-67" aria-hidden="true" tabindex="-1"></a>    nlen <span class="op">=</span> <span class="bu">len</span>(rin.nodes)</span>
<span id="cb14-68"><a href="#cb14-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-69"><a href="#cb14-69" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------------------</span></span>
<span id="cb14-70"><a href="#cb14-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># split useing svd, the right matrix</span></span>
<span id="cb14-71"><a href="#cb14-71" aria-hidden="true" tabindex="-1"></a>    u1, vt <span class="op">=</span> split_svd_rq(rin.nodes[nlen<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb14-72"><a href="#cb14-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-73"><a href="#cb14-73" aria-hidden="true" tabindex="-1"></a>    <span class="co">#can not use u and vt directly, some issues with dangling edge</span></span>
<span id="cb14-74"><a href="#cb14-74" aria-hidden="true" tabindex="-1"></a>    rout.nodes[nlen<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> vt</span>
<span id="cb14-75"><a href="#cb14-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-76"><a href="#cb14-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-77"><a href="#cb14-77" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------------------</span></span>
<span id="cb14-78"><a href="#cb14-78" aria-hidden="true" tabindex="-1"></a>    <span class="co">#intermediate terms</span></span>
<span id="cb14-79"><a href="#cb14-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nlen<span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb14-80"><a href="#cb14-80" aria-hidden="true" tabindex="-1"></a>        rtmp <span class="op">=</span> np.tensordot(rin.nodes[i], u1, ((<span class="dv">2</span>), (<span class="dv">0</span>)))</span>
<span id="cb14-81"><a href="#cb14-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-82"><a href="#cb14-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-83"><a href="#cb14-83" aria-hidden="true" tabindex="-1"></a>        u1, vt <span class="op">=</span> split_svd_rq(rtmp)</span>
<span id="cb14-84"><a href="#cb14-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-85"><a href="#cb14-85" aria-hidden="true" tabindex="-1"></a><span class="co"># can not use u and vt directly, some issues with dangling edge</span></span>
<span id="cb14-86"><a href="#cb14-86" aria-hidden="true" tabindex="-1"></a>        rout.nodes[i] <span class="op">=</span> vt</span>
<span id="cb14-87"><a href="#cb14-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-88"><a href="#cb14-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-89"><a href="#cb14-89" aria-hidden="true" tabindex="-1"></a><span class="co">#----------------------------------------------------</span></span>
<span id="cb14-90"><a href="#cb14-90" aria-hidden="true" tabindex="-1"></a><span class="co"># the left matrix</span></span>
<span id="cb14-91"><a href="#cb14-91" aria-hidden="true" tabindex="-1"></a>    rtmp <span class="op">=</span> np.tensordot(rin.nodes[<span class="dv">0</span>], u1, ((<span class="dv">2</span>), (<span class="dv">0</span>)))</span>
<span id="cb14-92"><a href="#cb14-92" aria-hidden="true" tabindex="-1"></a>    rout.nodes[<span class="dv">0</span>] <span class="op">=</span> rtmp</span>
<span id="cb14-93"><a href="#cb14-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-94"><a href="#cb14-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-95"><a href="#cb14-95" aria-hidden="true" tabindex="-1"></a>    <span class="co">#print("shape of rout",rout.ndim())</span></span>
<span id="cb14-96"><a href="#cb14-96" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rout</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Code for adding MPO tensors (in add_tensor.py) :</p>
<div id="06971826" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> copy <span class="im">as</span> cp</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co"># note, coeff only applies to the first node</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_tensor(r1, r2, coeff):</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    rtmp <span class="op">=</span> Density()</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    rtmp.nb <span class="op">=</span> r1.nb</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    nlen <span class="op">=</span> <span class="bu">len</span>(r1.nodes)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    type_r1 <span class="op">=</span> r1.nodes[<span class="dv">0</span>].dtype</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    type_r2 <span class="op">=</span> r2.nodes[<span class="dv">0</span>].dtype</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (type_r1 <span class="op">!=</span> type_r2):</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"r1 and r2 has different type, not supported yet"</span>)</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        sys.exit(<span class="dv">1</span>)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="co">#=============================================</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="co"># the left matrix, we should have m1=m2=1 here</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>    m1 <span class="op">=</span> r1.nodes[<span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    n1 <span class="op">=</span> r1.nodes[<span class="dv">0</span>].shape[<span class="dv">2</span>]</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    m2 <span class="op">=</span> r2.nodes[<span class="dv">0</span>].shape[<span class="dv">0</span>]</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    n2 <span class="op">=</span> r2.nodes[<span class="dv">0</span>].shape[<span class="dv">2</span>]</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    jj <span class="op">=</span> n1<span class="op">+</span>n2</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># combine data</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    vtmp <span class="op">=</span> np.zeros((<span class="dv">1</span>, r1.nb[<span class="dv">0</span>], jj), dtype<span class="op">=</span>type_r1)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    vtmp[<span class="dv">0</span>, :, <span class="dv">0</span>:n1] <span class="op">=</span> r1.nodes[<span class="dv">0</span>][<span class="dv">0</span>, :, :]</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>    vtmp[<span class="dv">0</span>, :, n1:jj] <span class="op">=</span> coeff<span class="op">*</span>r2.nodes[<span class="dv">0</span>][<span class="dv">0</span>, :, :]</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add to the nodes</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    rtmp.nodes.append(vtmp)</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="co">#================================================</span></span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="co"># add all the intermediate matrices</span></span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nlen<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>        m1 <span class="op">=</span> r1.nodes[i].shape[<span class="dv">0</span>]</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>        n1 <span class="op">=</span> r1.nodes[i].shape[<span class="dv">2</span>]</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>        m2 <span class="op">=</span> r2.nodes[i].shape[<span class="dv">0</span>]</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        n2 <span class="op">=</span> r2.nodes[i].shape[<span class="dv">2</span>]</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>        ii <span class="op">=</span> m1<span class="op">+</span>m2</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>        jj <span class="op">=</span> n1<span class="op">+</span>n2</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># combine data</span></span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a>        vtmp <span class="op">=</span> np.zeros((ii, r1.nb[i], jj), dtype<span class="op">=</span>type_r1)</span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>        vtmp[<span class="dv">0</span>:m1, :, <span class="dv">0</span>:n1] <span class="op">=</span> r1.nodes[i]</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a>        vtmp[m1:ii, :, n1:jj] <span class="op">=</span> r2.nodes[i]</span>
<span id="cb15-46"><a href="#cb15-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># add to the nodes</span></span>
<span id="cb15-47"><a href="#cb15-47" aria-hidden="true" tabindex="-1"></a>        rtmp.nodes.append(vtmp)</span>
<span id="cb15-48"><a href="#cb15-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-49"><a href="#cb15-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-50"><a href="#cb15-50" aria-hidden="true" tabindex="-1"></a><span class="co">#=============================================</span></span>
<span id="cb15-51"><a href="#cb15-51" aria-hidden="true" tabindex="-1"></a><span class="co"># the right matrix, we should have n1=n2=1 here</span></span>
<span id="cb15-52"><a href="#cb15-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-53"><a href="#cb15-53" aria-hidden="true" tabindex="-1"></a>    m1 <span class="op">=</span> r1.nodes[nlen<span class="op">-</span><span class="dv">1</span>].shape[<span class="dv">0</span>]</span>
<span id="cb15-54"><a href="#cb15-54" aria-hidden="true" tabindex="-1"></a>    n1 <span class="op">=</span> r1.nodes[nlen<span class="op">-</span><span class="dv">1</span>].shape[<span class="dv">2</span>]</span>
<span id="cb15-55"><a href="#cb15-55" aria-hidden="true" tabindex="-1"></a>    m2 <span class="op">=</span> r2.nodes[nlen<span class="op">-</span><span class="dv">1</span>].shape[<span class="dv">0</span>]</span>
<span id="cb15-56"><a href="#cb15-56" aria-hidden="true" tabindex="-1"></a>    n2 <span class="op">=</span> r2.nodes[nlen<span class="op">-</span><span class="dv">1</span>].shape[<span class="dv">2</span>]</span>
<span id="cb15-57"><a href="#cb15-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-58"><a href="#cb15-58" aria-hidden="true" tabindex="-1"></a>    ii <span class="op">=</span> m1<span class="op">+</span>m2</span>
<span id="cb15-59"><a href="#cb15-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># combine data</span></span>
<span id="cb15-60"><a href="#cb15-60" aria-hidden="true" tabindex="-1"></a>    vtmp <span class="op">=</span> np.zeros((ii, r1.nb[nlen<span class="op">-</span><span class="dv">1</span>], <span class="dv">1</span>), dtype<span class="op">=</span>type_r1)</span>
<span id="cb15-61"><a href="#cb15-61" aria-hidden="true" tabindex="-1"></a>    vtmp[<span class="dv">0</span>:m1, :, <span class="dv">0</span>] <span class="op">=</span> r1.nodes[nlen<span class="op">-</span><span class="dv">1</span>][:, :, <span class="dv">0</span>]</span>
<span id="cb15-62"><a href="#cb15-62" aria-hidden="true" tabindex="-1"></a>    vtmp[m1:ii, :, <span class="dv">0</span>] <span class="op">=</span> r2.nodes[nlen<span class="op">-</span><span class="dv">1</span>][:, :, <span class="dv">0</span>]</span>
<span id="cb15-63"><a href="#cb15-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-64"><a href="#cb15-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-65"><a href="#cb15-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># add to the nodes</span></span>
<span id="cb15-66"><a href="#cb15-66" aria-hidden="true" tabindex="-1"></a>    rtmp.nodes.append(vtmp)</span>
<span id="cb15-67"><a href="#cb15-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-68"><a href="#cb15-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-69"><a href="#cb15-69" aria-hidden="true" tabindex="-1"></a><span class="co">#===========================================</span></span>
<span id="cb15-70"><a href="#cb15-70" aria-hidden="true" tabindex="-1"></a><span class="co"># truncate the new tensor</span></span>
<span id="cb15-71"><a href="#cb15-71" aria-hidden="true" tabindex="-1"></a>    rtmp <span class="op">=</span> trun_tensor(rtmp)</span>
<span id="cb15-72"><a href="#cb15-72" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rtmp</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now, we can look at code for MPO construction (construct.py):</p>
<ul>
<li>Initially, the MPO is initialised in the same object as the MPS with all the MPS set to the identity.</li>
<li>Then a call is made to a function (delta_all5) that adds a bunch of tensors that makes an object “drho” that keeps getting relevant terms added it to it until it finally represents the completed MPO object.</li>
<li>First the system Hamiltonians “hsys” are added in the manner we described above. The tensors are shaped in a “stacked” way rather (1,<span class="math inline">\(\text{ndvr}^2\)</span>, 1) dimensions rather than (1, ndvr, ndvr, 1) as we might expect. This is some convenient representation, not sure why.</li>
<li>Then the bath terms (hbath) are added to the indices corresponding to the bath spins.</li>
<li>Then the spin-bath coupling terms are added, where you have an MPO with the <span class="math inline">\(\eta_i \sigma^{z}_0\)</span> in the positions corresponding to the system spin(?) and then an MPO corresponding to <span class="math inline">\(\sigma^x_i\)</span> in the positions corresponding to the bath spins(?).</li>
<li>I’m still a bit confused here, once I’m clear I will draw a picture of the MPOs for the spin-bath interaction terms.</li>
</ul>
<div id="0fffc108" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> construct():</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    p0 <span class="op">=</span> Density()</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    p0.nb <span class="op">=</span> nbmat</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co"># vl and vr</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    vl <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    vr <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        ii <span class="op">=</span> i<span class="op">*</span>ndvr<span class="op">+</span>i</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        vl[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        vr[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="co"># vmid</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    vmid <span class="op">=</span> []</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nbath<span class="op">*</span><span class="dv">2</span>):</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>        vtmp <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>            ii <span class="op">=</span> j<span class="op">*</span>ndvr<span class="op">+</span>j</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>            vtmp[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>        vmid.append(vtmp)</span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a><span class="co"># add to p0.nodes</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    p0.nodes.append(vl)</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nbath<span class="op">*</span><span class="dv">2</span>):</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>        p0.nodes.append(vmid[i])</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>    p0.nodes.append(vr)</span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'len of p0'</span>, <span class="bu">len</span>(p0.nodes))</span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"p0 calculation done!"</span>)</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>    rout <span class="op">=</span> delta_all5(p0)</span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rout</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a><span class="co">#==========================================================</span></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> delta_all5(rho):</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    drho <span class="op">=</span> rho.copy()</span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>    rtmp1 <span class="op">=</span> rho.copy()</span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    nlen <span class="op">=</span> <span class="bu">len</span>(rho.nodes)</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a><span class="co">#========================================================</span></span>
<span id="cb16-53"><a href="#cb16-53" aria-hidden="true" tabindex="-1"></a><span class="co"># the central spin Hamiltonian terms:</span></span>
<span id="cb16-54"><a href="#cb16-54" aria-hidden="true" tabindex="-1"></a>    vl1 <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-55"><a href="#cb16-55" aria-hidden="true" tabindex="-1"></a>    vl2 <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-56"><a href="#cb16-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-57"><a href="#cb16-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-58"><a href="#cb16-58" aria-hidden="true" tabindex="-1"></a>            ii <span class="op">=</span> j<span class="op">*</span>ndvr <span class="op">+</span> i</span>
<span id="cb16-59"><a href="#cb16-59" aria-hidden="true" tabindex="-1"></a>            vl1[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="ot">1.0j</span><span class="op">*</span>hsys[i, j]</span>
<span id="cb16-60"><a href="#cb16-60" aria-hidden="true" tabindex="-1"></a>            vl2[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="ot">1.0j</span><span class="op">*</span>hsys[j, i]</span>
<span id="cb16-61"><a href="#cb16-61" aria-hidden="true" tabindex="-1"></a>    drho.nodes[<span class="dv">0</span>] <span class="op">=</span> vl1</span>
<span id="cb16-62"><a href="#cb16-62" aria-hidden="true" tabindex="-1"></a>    rtmp1.nodes[<span class="dv">1</span>] <span class="op">=</span> vl2</span>
<span id="cb16-63"><a href="#cb16-63" aria-hidden="true" tabindex="-1"></a>    drho <span class="op">=</span> add_tensor(drho, rtmp1, <span class="fl">1.0</span>)</span>
<span id="cb16-64"><a href="#cb16-64" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"after hsys, shape of rout"</span>, drho.ndim())</span>
<span id="cb16-65"><a href="#cb16-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-66"><a href="#cb16-66" aria-hidden="true" tabindex="-1"></a><span class="co">#========================================================</span></span>
<span id="cb16-67"><a href="#cb16-67" aria-hidden="true" tabindex="-1"></a><span class="co"># the bath spins Hamiltonian terms:</span></span>
<span id="cb16-68"><a href="#cb16-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nbath):</span>
<span id="cb16-69"><a href="#cb16-69" aria-hidden="true" tabindex="-1"></a>        rtmp1 <span class="op">=</span> rho.copy()</span>
<span id="cb16-70"><a href="#cb16-70" aria-hidden="true" tabindex="-1"></a>        rtmp2 <span class="op">=</span> rho.copy()</span>
<span id="cb16-71"><a href="#cb16-71" aria-hidden="true" tabindex="-1"></a>        vtmp1 <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-72"><a href="#cb16-72" aria-hidden="true" tabindex="-1"></a>        vtmp2 <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-73"><a href="#cb16-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-74"><a href="#cb16-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(ndvr):  </span>
<span id="cb16-75"><a href="#cb16-75" aria-hidden="true" tabindex="-1"></a>                ii <span class="op">=</span> k<span class="op">*</span>ndvr <span class="op">+</span> j</span>
<span id="cb16-76"><a href="#cb16-76" aria-hidden="true" tabindex="-1"></a>                vtmp1[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="ot">1.0j</span><span class="op">*</span>hbath[i][j, k]</span>
<span id="cb16-77"><a href="#cb16-77" aria-hidden="true" tabindex="-1"></a>                vtmp2[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="ot">1.0j</span><span class="op">*</span>hbath[i][k, j]</span>
<span id="cb16-78"><a href="#cb16-78" aria-hidden="true" tabindex="-1"></a>        rtmp1.nodes[<span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>i] <span class="op">=</span> vtmp1</span>
<span id="cb16-79"><a href="#cb16-79" aria-hidden="true" tabindex="-1"></a>        rtmp2.nodes[<span class="dv">3</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>i] <span class="op">=</span> vtmp2 </span>
<span id="cb16-80"><a href="#cb16-80" aria-hidden="true" tabindex="-1"></a>        drho <span class="op">=</span> add_tensor(drho, rtmp1, <span class="fl">1.0</span>)</span>
<span id="cb16-81"><a href="#cb16-81" aria-hidden="true" tabindex="-1"></a>        drho <span class="op">=</span> add_tensor(drho, rtmp2, <span class="fl">1.0</span>)</span>
<span id="cb16-82"><a href="#cb16-82" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"after hbath, shape of rout"</span>, drho.ndim())</span>
<span id="cb16-83"><a href="#cb16-83" aria-hidden="true" tabindex="-1"></a><span class="co">#======================================================== </span></span>
<span id="cb16-84"><a href="#cb16-84" aria-hidden="true" tabindex="-1"></a><span class="co"># the spin-bath coupling Hamiltonian</span></span>
<span id="cb16-85"><a href="#cb16-85" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nbath):</span>
<span id="cb16-86"><a href="#cb16-86" aria-hidden="true" tabindex="-1"></a>        rtmp1 <span class="op">=</span> rho.copy()</span>
<span id="cb16-87"><a href="#cb16-87" aria-hidden="true" tabindex="-1"></a>        rtmp2 <span class="op">=</span> rho.copy() </span>
<span id="cb16-88"><a href="#cb16-88" aria-hidden="true" tabindex="-1"></a>    <span class="co"># H \rho for qubit part</span></span>
<span id="cb16-89"><a href="#cb16-89" aria-hidden="true" tabindex="-1"></a>        vtmp11 <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-90"><a href="#cb16-90" aria-hidden="true" tabindex="-1"></a>    <span class="co"># \rho H for qubit part</span></span>
<span id="cb16-91"><a href="#cb16-91" aria-hidden="true" tabindex="-1"></a>        vtmp21 <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-92"><a href="#cb16-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-93"><a href="#cb16-93" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-94"><a href="#cb16-94" aria-hidden="true" tabindex="-1"></a>                ii <span class="op">=</span> k<span class="op">*</span>ndvr <span class="op">+</span> j</span>
<span id="cb16-95"><a href="#cb16-95" aria-hidden="true" tabindex="-1"></a>                vtmp11[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="op">-</span><span class="ot">1.0j</span><span class="op">*</span>sigma_z[j, k]<span class="op">*</span>eta_sb[i]</span>
<span id="cb16-96"><a href="#cb16-96" aria-hidden="true" tabindex="-1"></a>                vtmp21[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> <span class="ot">1.0j</span><span class="op">*</span>sigma_z[k, j]<span class="op">*</span>eta_sb[i]</span>
<span id="cb16-97"><a href="#cb16-97" aria-hidden="true" tabindex="-1"></a>    <span class="co"># H \rho for spins part</span></span>
<span id="cb16-98"><a href="#cb16-98" aria-hidden="true" tabindex="-1"></a>        vtmp12 <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-99"><a href="#cb16-99" aria-hidden="true" tabindex="-1"></a>    <span class="co"># \rho H for spins part</span></span>
<span id="cb16-100"><a href="#cb16-100" aria-hidden="true" tabindex="-1"></a>        vtmp22 <span class="op">=</span> np.zeros((<span class="dv">1</span>, ndvr<span class="op">*</span>ndvr, <span class="dv">1</span>), dtype<span class="op">=</span>np.complex128)</span>
<span id="cb16-101"><a href="#cb16-101" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-102"><a href="#cb16-102" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(ndvr):</span>
<span id="cb16-103"><a href="#cb16-103" aria-hidden="true" tabindex="-1"></a>                ii <span class="op">=</span> k<span class="op">*</span>ndvr <span class="op">+</span> j</span>
<span id="cb16-104"><a href="#cb16-104" aria-hidden="true" tabindex="-1"></a>                vtmp12[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> sigma_x[j, k]</span>
<span id="cb16-105"><a href="#cb16-105" aria-hidden="true" tabindex="-1"></a>                vtmp22[<span class="dv">0</span>, ii, <span class="dv">0</span>] <span class="op">=</span> sigma_x[k, j]</span>
<span id="cb16-106"><a href="#cb16-106" aria-hidden="true" tabindex="-1"></a>        rtmp1.nodes[<span class="dv">0</span>] <span class="op">=</span> vtmp11</span>
<span id="cb16-107"><a href="#cb16-107" aria-hidden="true" tabindex="-1"></a>        rtmp1.nodes[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">2</span>] <span class="op">=</span> vtmp12</span>
<span id="cb16-108"><a href="#cb16-108" aria-hidden="true" tabindex="-1"></a>        rtmp2.nodes[<span class="dv">1</span>] <span class="op">=</span> vtmp21</span>
<span id="cb16-109"><a href="#cb16-109" aria-hidden="true" tabindex="-1"></a>        rtmp2.nodes[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">3</span>] <span class="op">=</span> vtmp22</span>
<span id="cb16-110"><a href="#cb16-110" aria-hidden="true" tabindex="-1"></a>        drho <span class="op">=</span> add_tensor(drho, rtmp1, <span class="fl">1.0</span>)</span>
<span id="cb16-111"><a href="#cb16-111" aria-hidden="true" tabindex="-1"></a>        drho <span class="op">=</span> add_tensor(drho, rtmp2, <span class="fl">1.0</span>)</span>
<span id="cb16-112"><a href="#cb16-112" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"after qs interaction, shape of rout"</span>, drho.ndim())</span>
<span id="cb16-113"><a href="#cb16-113" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> drho</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Testing:</p>
<div id="3be9a70b" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> construct()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>len of p0 6
p0 calculation done!
after hsys, shape of rout [[1 2 2 2 2 2]
 [4 4 4 4 4 4]
 [2 2 2 2 2 1]]
after hbath, shape of rout [[1 3 3 3 3 3]
 [4 4 4 4 4 4]
 [3 3 3 3 3 1]]
after qs interaction, shape of rout [[1 4 5 5 5 4]
 [4 4 4 4 4 4]
 [4 5 5 5 4 1]]</code></pre>
</div>
</div>
</section>
<section id="contraction" class="level1">
<h1>Contraction</h1>
<ul>
<li><p>Relevant properties related to the system spin come from a trace over the bath spin quantities. I need to review this part as well. <img src="mps-figs/contract.png" class="img-fluid" alt="contraction"></p></li>
<li><p>For each bath spin, do the relevant matrix multiplication and then take a trace of the multiplied matrix, then repeat until you get only one node to get the relevant density matrix properties that you want.</p></li>
</ul>
<p>This code snippet is from calc_rho.py :</p>
<div id="c1c5f4ef" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calc_rho(rin):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    nlen <span class="op">=</span> <span class="bu">len</span>(rin.nodes)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.dot(rin.nodes[<span class="dv">0</span>][<span class="dv">0</span>,<span class="dv">0</span>,:], rin.nodes[<span class="dv">1</span>][:,<span class="dv">0</span>,:])</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.tensordot(rho, rin.nodes[<span class="dv">2</span>], axes<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.tensordot(rho, rin.nodes[<span class="dv">3</span>], axes<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">0</span>))</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.trace(rho, axis1<span class="op">=</span><span class="dv">0</span>, axis2<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nbath<span class="op">-</span><span class="dv">2</span>):</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>        rho <span class="op">=</span> np.tensordot(rho, rin.nodes[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">4</span>], axes<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>)) </span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>        rho <span class="op">=</span> np.tensordot(rho, rin.nodes[<span class="dv">2</span><span class="op">*</span>i<span class="op">+</span><span class="dv">5</span>], axes<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">0</span>))</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>        rho <span class="op">=</span> np.trace(rho, axis1<span class="op">=</span><span class="dv">0</span>, axis2<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.tensordot(rho, rin.nodes[nlen<span class="op">-</span><span class="dv">2</span>], axes<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">0</span>))</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.dot(rho, rin.nodes[nlen<span class="op">-</span><span class="dv">1</span>][:,:,<span class="dv">0</span>])</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    rho <span class="op">=</span> np.trace(rho, axis1<span class="op">=</span><span class="dv">0</span>, axis2<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> rho</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="propagation" class="level1">
<h1>Propagation</h1>
<section id="rk-4" class="level2">
<h2 class="anchored" data-anchor-id="rk-4">RK-4</h2>
</section>
<section id="tebd" class="level2">
<h2 class="anchored" data-anchor-id="tebd">TEBD</h2>
</section>
<section id="dmrg" class="level2">
<h2 class="anchored" data-anchor-id="dmrg">DMRG</h2>
</section>
<section id="tdvp" class="level2">
<h2 class="anchored" data-anchor-id="tdvp">TDVP</h2>
</section>
</section>
<section id="dissipative-dynamics-in-mps" class="level1">
<h1>Dissipative Dynamics in MPS</h1>
<ul>
<li>Adding Lindblad operators to the MPS (Ref 2 has it).</li>
</ul>
</section>
<section id="appendix-a-singular-value-decompositions-svds-and-qr" class="level1">
<h1>Appendix A : Singular Value Decompositions (SVDs) and QR</h1>
<p>See my notes on <a href="https://chemicalfiend.github.io/half-baked-ideas/MatrixFactorisations.html">matrix factorisations</a>. They explain what is an SVD and why we use SVD as opposed to any other matrix decomposition for MPS preparation.</p>
</section>
<section id="appendix-b-direct-products-and-direct-sums-otimes-and-oplus" class="level1">
<h1>Appendix B : Direct Products and Direct Sums (otimes and oplus)</h1>
<p>See my notes on <a href="https://chemicalfiend.github.io/half-baked-ideas/otimesplus.html">direct products and sums</a>. They explain the logic behind some of the tensor operations and why the MPO we constructed has the form that it does.</p>
</section>
<section id="resources-to-read" class="level1">
<h1>Resources / To-Read</h1>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLoRej1xZVKONjda7KSfwVpBIiKWAHt4kh">My MPS Playlist</a></li>
<li>Schollwoeck’s entire DMRG in the age of MPS</li>
<li><a href="https://doi.org/10.48550/arXiv.cond-mat/0406426">MPS Construction for finite-T Mixed States</a></li>
<li>Krylov subspace methods for MPS.</li>
<li>TDVP paper and implement in very simple form</li>
<li>Frank Pollman Lectures at BSS2023 (in the playlist) and <a href="https://nextcloud.tfk.ph.tum.de/cmt/index.php/apps/cms_pico/pico/mps_tutorial_2013">lecture notes</a></li>
</ul>
<!--
# Normalisation

- The left normalisation condition is $I = \sum_{\sigma_l} M^{\sigma_l \dagger} M^{\sigma_l} \equiv A^{\sigma_l \dagger} A^{\sigma_l}$ (contract the left indices)
- The right normalisation condition is $I = \sum_{\sigma_l} M^{\sigma_l \dagger} M^{\sigma_l} \equiv B^{\sigma_l} B^{\sigma_l \dagger}$ (contract over the right indices)
- As and Bs are used to denote MPS's that are left and right normalised respectively.
- Mixed normalisation : we often start with left normalisation and then have some that don't have any particular form of left or right normalisation and then right normalisation of the form $AAAAMBBBBB$.

# MPO

## General MPO Operator

- The operators are built from projection operators from the basis states. $\hat{O} = \sum\limits_{\sigma}\sum\limits_{\sigma'} c^{\sigma_1 ... \sigma_L, \sigma'_1 ... \sigma'_L} |\sigma_1 ...\sigma_L\rangle \langle\sigma'_1 ...\sigma'_L|$
- If you rearrange indices, the mean-field construction is very straightforward. $c^{\sigma_1 ... \sigma_L, \sigma'_1 ... \sigma'_L} = c^{\sigma_1 \sigma'_1 ... \sigma_L, \sigma'_L} = c^{\sigma_1 \sigma'_1} c^{\sigma_2 \sigma'_2} ... c^{\sigma_L \sigma'_L}$
- For example the $S_i^z$ operator (or any other local observable) in mean-field is exact. $S_i^{z}$ is just identity on operator on every site except site i where you have the $S_i^{z}$ operator.
- Which means the coefficients are of the form : $c^{\sigma_1, \sigma'_1 ... \sigma_L, \sigma'_L} = \delta_{\sigma_1 \sigma'_1} ... (S_z)_{\sigma_i \sigma'_i} ... \delta_{\sigma_{L}, \sigma'_{L}}$ where $(S_z)_{\sigma_i \sigma'_i}$ is the matrix element of $S_z$.
- Similarly in the matrix product sense, we get : $\hat{O} = \sum\limits_{\sigma}\sum\limits_{\sigma'} M^{\sigma_1 \sigma'_1} M^{\sigma_2 \sigma'_2} ... M^{\sigma_L \sigma'_L} |\sigma_1 ...\sigma_L\rangle \langle\sigma'_1 ...\sigma'_L| $

## Compression and Normalisation

- TODO : come back and finish this part I didn't understand it at all. 
- If we have an operator that is a matrix product and a state that is a matrix product. If we apply an MPO to this MPS, the dimensionality increases. This makes life hard.
- If a state is in the mixed normalised form $|\psi\rangle = \sum\limits_{\{\sigma\}}A^{\sigma_1} ... A^{\sigma_l} M^{\sigma_{l+1}} B^{\sigma_{l+2}} ... B^{\sigma_L} |\sigma_1 ... \sigma_L\rangle$
- For the M matrices (there are d of them), undo the splicing : so you stack them up. $M_{a_l, \sigma_{l+1} a_{l+1}} = M^{\sigma_l}_{a_l, a_{l+1}}$
- Carry out an SVD. 

# Mixed State MPS Propagation

- Okay so now we have been able to prepare a matrix product state for a pure state $\psi$ and create operators that will help us propagate it.
- What do we do if we have a density matrix $\rho$ (mixed state) instead?
- One of the methods to deal with a mixed-state density matrix $\rho$ is to perform a "purification" operation (see Ref. 2). Another way is to sample over Minimally Entangled Typical Thermal States (METTS).

## Purification

-->
<!--
- We are trying to evolve $|\psi(t)\rangle = \exp(-i H t) |\psi(0)\rangle$. Challenge - express evolution operator as an MPO.
- Solution : Trotterization! 
-->
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>